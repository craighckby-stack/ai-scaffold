import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import ReactDOM from 'react-dom/client'; // Assuming modern React usage

// --- SECURITY & UTILS ---
const SAFE_ENCODE = (str) => btoa(unescape(encodeURIComponent(str)));
const SAFE_DECODE = (str) => {
    if (!str) return "";
    try { 
        // Handles base64 encoded strings, removing newlines often present in GitHub content
        const standardBase64 = str.replace(/\n/g, ''); 
        return decodeURIComponent(escape(atob(standardBase64))); 
    }
    catch (e) { return ""; }
};

const sanitize = (input, type = 'text') => {
    // Allows standard alphanumeric, hyphens, underscores, and dots for GH naming
    if (type === 'github') return input.replace(/[^a-zA-Z0-9\-_.]/g, '').trim().slice(0, 50);
    // General sanitization for secrets (removes control characters)
    return input.replace(/[^\x20-\x7E]/g, '').trim();
};

const STORAGE_KEYS = {
    TOKEN: 'ev_token', KEY: 'ev_gemini', OWNER: 'ev_owner', REPO: 'ev_repo', BRANCH: 'ev_branch'
};

// --- ERROR BOUNDARY ---
class ErrorBoundary extends React.Component {
    state = { hasError: false, error: null };
    static getDerivedStateFromError(error) { return { hasError: true, error }; }
    
    componentDidCatch(error, errorInfo) {
        console.error("Component Error Boundary caught:", error, errorInfo);
    }

    render() {
        if (this.state.hasError) return (
            <div className="h-screen bg-black flex flex-col items-center justify-center p-6 text-red-600 font-mono text-center">
                <p className="text-xs mb-4 uppercase tracking-tighter">Core Fault Detected: {this.state.error?.message || 'Unknown Error'}</p>
                <button onClick={() => window.location.reload()} className="border border-red-900 px-4 py-2 text-[10px] text-red-600 mt-4 hover:bg-red-900 hover:text-black transition-colors">REBOOT SYSTEM</button>
            </div>
        );
        return this.props.children;
    }
}

// --- CORE LOGIC ---
function DarlikKhanCore() {
    const [state, setState] = useState({
        isRunning: false,
        logs: [],
        preview: { path: '', before: '', after: '', status: 'STANDBY' },
        principles: { IR: 0, SI: 0, DI: 0, AC: 0 },
        isSaving: false
    });

    // Use Refs for heavy-duty state that doesn't trigger render loop (performance optimization)
    const refs = {
        before: useRef(null),
        after: useRef(null),
        logEnd: useRef(null),
        abort: useRef(null),
        loop: useRef(false),
        paths: useRef(new Set()),
        branch: useRef(localStorage.getItem(STORAGE_KEYS.BRANCH) || null),
        cachedTree: useRef(null)
    };

    const [config, setConfig] = useState(() => ({
        ghToken: SAFE_DECODE(localStorage.getItem(STORAGE_KEYS.TOKEN) || ''),
        geminiKey: SAFE_DECODE(localStorage.getItem(STORAGE_KEYS.KEY) || ''),
        repoOwner: localStorage.getItem(STORAGE_KEYS.OWNER) || '',
        repoName: localStorage.getItem(STORAGE_KEYS.REPO) || ''
    }));

    // Update Text Content directly to prevent massive DOM re-renders from large code blocks in state
    useEffect(() => {
        if (refs.before.current) refs.before.current.textContent = state.preview.before;
        if (refs.after.current) refs.after.current.textContent = state.preview.after;
    }, [state.preview.before, state.preview.after]);

    const addLog = useCallback((msg, type = 'info', principle = null) => {
        setState(prev => {
            const time = new Date().toLocaleTimeString([], { hour12: false, hour: '2-digit', minute: '2-digit' });
            const newLogs = [...prev.logs, { id: crypto.randomUUID(), msg, type, time }].slice(-50);
            
            let newPrinciples = prev.principles;
            if (principle) {
                newPrinciples = { ...newPrinciples, [principle]: newPrinciples[principle] + 1 };
            }
            return { ...prev, logs: newLogs, principles: newPrinciples };
        });
    }, []);

    const jitterSleep = async (base) => {
        const ms = base + Math.floor(Math.random() * 10000); 
        await new Promise(r => setTimeout(r, ms, refs.abort.current?.signal));
    };

    const fetchAPI = async (url, options, retries = 3) => {
        const headers = { 
            'Authorization': `token ${config.ghToken}`, 
            'Accept': 'application/vnd.github.v3+json',
            ...options.headers 
        };

        for(let i = 0; i < retries; i++) {
            try {
                const res = await fetch(url, { ...options, headers, signal: refs.abort.current?.signal });
                
                if (res.status === 429) {
                    addLog("RATE_LIMIT: CORE COOLING 30S", "warning", "AC");
                    await new Promise(r => setTimeout(r, 30000));
                    continue;
                }
                if (!res.ok) {
                    const errorBody = await res.text();
                    throw new Error(`HTTP ${res.status} error: ${errorBody.slice(0, 100)}`);
                }
                
                const text = await res.text();
                return text ? JSON.parse(text) : null;
            } catch (e) {
                if (e.name === 'AbortError') throw e;
                if (i === retries - 1) throw e;
                addLog(`Network/API fault. Retrying ${i + 1}/${retries}.`, "warning");
                await jitterSleep(3000 * (i + 1));
            }
        }
    };

    const start = async () => {
        if (refs.loop.current) return;
        refs.loop.current = true;
        setState(p => ({ ...p, isRunning: true }));
        addLog("SYSTEM_ENGAGED: SEEKING MUTATION TARGETS", "success", "IR");

        try {
            refs.abort.current = new AbortController();
            
            // 1. Initialize dedicated evolution branch if necessary
            if (!refs.branch.current) {
                const main = await fetchAPI(`https://api.github.com/repos/${config.repoOwner}/${config.repoName}/branches/main`, { method: 'GET' });
                const bName = `darlik-khan/evolution-${Date.now()}`;
                
                await fetchAPI(`https://api.github.com/repos/${config.repoOwner}/${config.repoName}/git/refs`, {
                    method: 'POST', body: JSON.stringify({ ref: `refs/heads/${bName}`, sha: main.commit.sha })
                });
                
                refs.branch.current = bName;
                localStorage.setItem(STORAGE_KEYS.BRANCH, bName);
                addLog(`Evolution branch established: ${bName}`, "info");
            }

            while (refs.loop.current) {
                // 2. Refresh tree periodically or if paths set is large
                if (!refs.cachedTree.current || refs.paths.current.size > 50) {
                    const treeRes = await fetchAPI(`https://api.github.com/repos/${config.repoOwner}/${config.repoName}/git/trees/main?recursive=1`, { method: 'GET' });
                    refs.cachedTree.current = treeRes.tree.filter(f => 
                        f.type === 'blob' && 
                        f.size < 50000 && 
                        !f.path.match(/\.(png|jpg|ico|zip|lock|svg|min\.js|dist\/|build\/|node_modules)/i)
                    );
                    
                    if (refs.paths.current.size > refs.cachedTree.current.length / 2 && refs.cachedTree.current.length > 5) {
                        refs.paths.current.clear();
                        addLog("Path cache cleared. Re-evaluating.", "warning");
                    }
                    addLog(`Scanned ${refs.cachedTree.current.length} potential targets.`, "info", "SI");
                }
                
                const candidates = refs.cachedTree.current.filter(f => !refs.paths.current.has(f.path));
                
                if (candidates.length === 0) { 
                    addLog("All known paths optimized. Initiating long scan cycle.", "success"); 
                    refs.paths.current.clear(); // Soft reset
                    refs.cachedTree.current = null; // Force refresh tree
                    await jitterSleep(60000); 
                    continue; 
                }

                const target = candidates[Math.floor(Math.random() * candidates.length)];

                setState(p => ({ ...p, preview: { ...p.preview, path: target.path, status: 'LOCKING' } }));
                addLog(`TARGET LOCKED: ${target.path}`, "warning");
                
                const fileRes = await fetchAPI(`https://api.github.com/repos/${config.repoOwner}/${config.repoName}/contents/${target.path}?ref=main`, { method: 'GET' });
                const original = SAFE_DECODE(fileRes.content);
                setState(p => ({ ...p, preview: { ...p.preview, before: original, status: 'MUTATING' } }));

                // 3. AI Evolution
                const prompt = `You are DARLIK KHAN, an AI dedicated to superior code evolution. You must optimize the provided code for structure, performance, and bug fixes. Only return the raw, evolved code. Do not add any explanatory text, commentary, or markdown markers (e.g., \`\`\`js). The output must be ready to replace the input file exactly.\n\nFILE: ${target.path}\nCODE:\n${original}`;

                const gemini = await fetchAPI(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${config.geminiKey}`, {
                    method: 'POST',
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });

                const rawResponseText = gemini.candidates?.[0]?.content?.parts?.[0]?.text || '';
                let evolved = rawResponseText.replace(/^```[a-z]*\n/i, '').replace(/\n```$/, '').trim();

                // 4. Commit Check
                if (evolved.length > 10 && evolved !== original.trim()) {
                    await fetchAPI(`https://api.github.com/repos/${config.repoOwner}/${config.repoName}/contents/${target.path}`, {
                        method: 'PUT', 
                        body: JSON.stringify({ 
                            message: `DARLIK_KHAN: EVOLVED NODE ${target.path}`, 
                            content: SAFE_ENCODE(evolved), 
                            sha: fileRes.sha, 
                            branch: refs.branch.current 
                        })
                    });
                    setState(p => ({ ...p, preview: { ...p.preview, after: evolved, status: 'COMMITTED' } }));
                    addLog(`EVOLVED: ${target.path}`, "success", "DI");
                } else {
                    setState(p => ({ ...p, preview: { ...p.preview, after: evolved, status: 'STABLE' } }));
                    addLog(`NODE OPTIMAL: ${target.path}`, "info");
                }

                refs.paths.current.add(target.path);
                addLog("Coating phase initiated...", "info", "AC");
                await jitterSleep(15000);
                setState(p => ({ ...p, preview: { path: '', before: '', after: '', status: 'STANDBY' } }));
            }
        } catch (e) { 
            if (e.name !== 'AbortError') {
                addLog(`CRITICAL FAULT: ${e.message}`, "error"); 
                await jitterSleep(30000);
            }
            stop(); 
        }
    };

    const stop = () => { 
        refs.loop.current = false; 
        setState(p => ({ ...p, isRunning: false }));
        refs.abort.current?.abort();
        addLog("SYSTEM HALTED.", "error", "AC"); 
    };

    const save = async () => {
        if (!config.ghToken || !config.geminiKey || !config.repoOwner || !config.repoName) return;
        setState(p => ({ ...p, isSaving: true }));
        
        localStorage.setItem(STORAGE_KEYS.TOKEN, SAFE_ENCODE(config.ghToken));
        localStorage.setItem(STORAGE_KEYS.KEY, SAFE_ENCODE(config.geminiKey));
        localStorage.setItem(STORAGE_KEYS.OWNER, config.repoOwner);
        localStorage.setItem(STORAGE_KEYS.REPO, config.repoName);
        
        // Ensure branch is cleared if we change owner/repo, forcing recreation
        if (config.repoOwner !== localStorage.getItem(STORAGE_KEYS.OWNER) || config.repoName !== localStorage.getItem(STORAGE_KEYS.REPO)) {
             localStorage.removeItem(STORAGE_KEYS.BRANCH);
        }

        window.location.reload();
    };

    useEffect(() => { refs.logEnd.current?.scrollIntoView({ behavior: 'smooth' }); }, [state.logs]);
    useEffect(() => stop, []); // Cleanup on unmount

    const isConfigMissing = !(config.ghToken && config.geminiKey && config.repoOwner && config.repoName);

    return (
        <div className="h-screen w-full flex flex-col bg-black text-zinc-500 font-mono overflow-hidden touch-manipulation">
            {/* Header */}
            <header className="flex-none h-12 border-b border-zinc-900 flex items-center justify-between px-4 bg-black z-10">
                <div className="flex flex-col">
                    <h1 className="text-[10px] font-bold text-red-900 tracking-tighter">DARLIK_KHAN CORE</h1>
                    <span className="text-[7px] opacity-40 uppercase">EMG_MOBILE_CORE_V4</span>
                </div>
                <button 
                    onClick={state.isRunning ? stop : start} 
                    disabled={isConfigMissing}
                    className={`text-[9px] px-4 py-2 border rounded-sm transition-colors ${state.isRunning ? 'border-red-900 text-red-600' : 'border-zinc-800 text-zinc-400'}`}
                >
                    {state.isRunning ? 'HALT_OPERATIONS' : 'ENGAGE_SYSTEM'}
                </button>
            </header>

            {/* Principles Bar - Scrollable on very small screens */}
            <div className="flex-none h-6 border-b border-zinc-900 flex items-center gap-4 px-4 overflow-x-auto no-scrollbar bg-[#050505] text-[7px] font-bold">
                {Object.entries(state.principles).map(([k, v]) => (
                    <span key={k} className="whitespace-nowrap">
                        {k}: <span className="text-zinc-300">{v}</span>
                    </span>
                ))}
                <span className="ml-auto text-zinc-700">BRANCH: {refs.branch.current || 'N/A'}</span>
            </div>

            {/* Main Content Area: Responsive Flex */}
            <main className="flex-1 flex flex-col md:flex-row overflow-hidden">
                <section className="flex-1 flex flex-col border-b md:border-b-0 md:border-r border-zinc-900 overflow-hidden">
                    <div className="h-6 bg-zinc-950 px-2 flex items-center text-[7px] text-zinc-600 uppercase border-b border-zinc-900 truncate">Source: {state.preview.path || 'idle'}</div>
                    <div ref={refs.before} className="flex-1 p-3 text-[10px] leading-relaxed opacity-30 overflow-auto whitespace-pre-wrap select-none scrollbar-hide" />
                </section>
                <section className="flex-1 flex flex-col overflow-hidden bg-[#020202]">
                    <div className="h-6 bg-zinc-950 px-2 flex items-center justify-between text-[7px] border-b border-zinc-900 uppercase">
                        <span className="text-zinc-600">Mutation_State</span>
                        <span className="text-red-900 font-bold">{state.preview.status}</span>
                    </div>
                    <div ref={refs.after} className="flex-1 p-3 text-[10px] leading-relaxed text-red-800/80 overflow-auto whitespace-pre-wrap scrollbar-hide" />
                </section>
            </main>

            {/* Logs Area */}
            <footer className="flex-none h-32 border-t border-zinc-900 bg-black overflow-y-auto p-3 space-y-1">
                {state.logs.map(l => (
                    <div key={l.id} className="text-[8px] flex gap-2 border-l border-zinc-900 pl-2">
                        <span className="opacity-30">[{l.time}]</span>
                        <span className={l.type === 'success' ? 'text-green-800' : l.type === 'error' ? 'text-red-800' : 'text-zinc-500'}>{l.msg}</span>
                    </div>
                ))}
                <div ref={refs.logEnd} />
            </footer>

            {/* Auth Overlay */}
            {isConfigMissing && (
                <div className="fixed inset-0 bg-black/98 z-50 flex flex-col items-center justify-center p-6 backdrop-blur-sm">
                    <div className="w-full max-w-xs space-y-4">
                        <h2 className="text-center text-red-900 text-xs font-bold tracking-[0.4em] mb-6">CORE_SYNC_REQUIRED</h2>
                        <div className="space-y-3">
                            <input placeholder="GH_OWNER" value={config.repoOwner} onChange={e => setConfig(c => ({...c, repoOwner: sanitize(e.target.value, 'github')}))} className="w-full bg-zinc-950 border border-zinc-900 p-3 text-[10px] text-zinc-400 outline-none rounded-sm" />
                            <input placeholder="REPO_NAME" value={config.repoName} onChange={e => setConfig(c => ({...c, repoName: sanitize(e.target.value, 'github')}))} className="w-full bg-zinc-950 border border-zinc-900 p-3 text-[10px] text-zinc-400 outline-none rounded-sm" />
                            <input type="password" placeholder="GH_TOKEN" value={config.ghToken} onChange={e => setConfig(c => ({...c, ghToken: sanitize(e.target.value)}))} className="w-full bg-zinc-950 border border-zinc-900 p-3 text-[10px] text-zinc-400 outline-none rounded-sm" />
                            <input type="password" placeholder="GEMINI_KEY" value={config.geminiKey} onChange={e => setConfig(c => ({...c, geminiKey: sanitize(e.target.value)}))} className="w-full bg-zinc-950 border border-zinc-900 p-3 text-[10px] text-zinc-400 outline-none rounded-sm" />
                        </div>
                        <button 
                            disabled={state.isSaving || isConfigMissing} 
                            onClick={save} 
                            className="w-full bg-red-950/20 border border-red-900 text-red-600 py-3 text-[10px] font-bold uppercase tracking-widest active:bg-red-900 active:text-black disabled:opacity-50"
                        >
                            {state.isSaving ? 'Synchronizing...' : 'Establish_Link'}
                        </button>
                    </div>
                </div>
            )}
        </div>
    );
}

export default function App() {
    return (
        <ErrorBoundary>
            <DarlikKhanCore />
        </ErrorBoundary>
    );
}